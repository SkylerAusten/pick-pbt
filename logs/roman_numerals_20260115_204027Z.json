{
  "timestamp_utc": "20260115_204027Z",
  "problem": "roman_numerals",
  "settings": {
    "FREEFORM_SPEC": false,
    "MODEL_NAME": "gemini-2.5-flash",
    "TEMPERATURE": 0.2,
    "MAX_OUTPUT_TOKENS": null,
    "TIMEOUT_SEC": 60,
    "python_version": "3.11.2 (main, Apr 28 2025, 14:11:48) [GCC 12.2.0]",
    "platform": "Linux-6.1.0-42-amd64-x86_64-with-glibc2.36"
  },
  "prompts": {
    "properties_prompt": "You are helping me generate property-based tests (PBT) in Python.\nMy test framework will be Hypothesis.\n\nProblem specification:\n<background>\nThis problem concerns conversion between (1) positive integers and (2) their canonical Roman numeral string representations.\n\nRoman numerals use seven symbols with fixed values:\n\t- I=1, V=5, X=10, L=50, C=100, D=500, M=1000.\n\nNumeral formation rules (canonical form):\n\t1) Additive principle: if a symbol appears after a symbol of equal or greater value, its value is added.\n\t\t Example: VI = 5 + 1 = 6.\n\t2) Subtractive principle: if a symbol appears before a symbol of greater value, its value is subtracted.\n\t\t Subtraction is restricted to these pairs only:\n\t\t\t - I before V or X (IV=4, IX=9)\n\t\t\t - X before L or C (XL=40, XC=90)\n\t\t\t - C before D or M (CD=400, CM=900)\n\t3) Repetition limits:\n\t\t\t - V, L, D must not repeat.\n\t\t\t - I, X, C, M may repeat at most 3 times consecutively.\n\t4) Order of magnitude: symbols are arranged from highest to lowest value left-to-right, except for the allowed subtractive pairs.\n\nNumeric domain:\n\t- Standard Roman numerals are defined for integers N where 1 <= N <= 3999.\n\t- The output of integer-to-Roman conversion must be a canonical string consistent with the rules above.\n</background>\n\n<custom_data_types>\nN/A\n</custom_data_types>\n\n<function_signature>\n\t- Signature: to_numerals(N: int) -> str\n\t- Meaning: Convert integer N into its canonical RomanNumeralString.\n</function_signature>\n\n<function_details>\nFunction: to_numerals\n\tInputs:\n\t\t- N: integer.\n\tPreconditions:\n\t\t- N must satisfy 1 <= N <= 3999.\n\tOutput:\n\t\t- Returns a canonical RomanNumeralString representing N.\n\tPostconditions:\n\t\t- The returned string obeys all canonical formation rules.\n\t\t- from_numerals(to_numerals(N)) == N.\n\tAlgorithmic behavior (required at the level of the mapping, not implementation details):\n\t\t- The conversion must be consistent with a greedy decomposition over the following value-to-token list in descending order:\n\t\t\t\t1000->M, 900->CM, 500->D, 400->CD, 100->C, 90->XC, 50->L, 40->XL, 10->X, 9->IX, 5->V, 4->IV, 1->I.\n\t\t- At each step, append the token while its value fits into the remaining amount, subtracting accordingly, until remainder is 0.\n\tError handling:\n\t\t- If N is outside the domain [1, 3999], the function must raise an exception (e.g., ValueError) indicating out-of-range.\n\t\t- If N is not an integer type, the function must raise an exception (e.g., TypeError) indicating invalid input type.\n</function_details>\n\nLabeled spec expectations (freeform_spec=false):\n- <background>: high-level context, definitions, and rules.\n- <custom_data_types>: any custom types, encodings, invariants, examples.\n- <function_signature>: names, parameters, return types (as text), and meaning.\n- <function_details>: precise behavior, preconditions, postconditions, errors.\n\nTask:\n- Produce 15 distinct properties of the target function(s).\n- Each property MUST be testable via random data generation (Hypothesis).\n- Phrase each property precisely using quantifiers like 'for all' / 'there exists' and include any necessary preconditions.\n- Include edge cases, invariants, metamorphic properties, and error/exception behavior when relevant.\n- Do NOT include any code.\n\nOutput requirements (STRICT):\n- Output MUST be valid JSON and NOTHING ELSE.\n- Output MUST be exactly ONE JSON object matching one of the schemas below.\n\nSchema A (success):\n{\n  \"result\": [\n    <property description string>,\n    <property description string>,\n    ...\n  ],\n  \"explanation\": null\n}\n\nSchema B (insufficient/unknown):\n{\n  \"result\": null,\n  \"explanation\": <string describing what is missing / ambiguous and what to add>\n}\n\nAdditional constraints:\n- Each property in result is a string describing one property statement.\n- Do not wrap in Markdown. Do not include code blocks.",
    "signature_strategy_prompt": "You are helping me generate property-based tests (PBT) in Python.\nMy test framework will be Hypothesis.\n\nProblem name: roman_numerals\n\nProblem specification:\n<background>\nThis problem concerns conversion between (1) positive integers and (2) their canonical Roman numeral string representations.\n\nRoman numerals use seven symbols with fixed values:\n\t- I=1, V=5, X=10, L=50, C=100, D=500, M=1000.\n\nNumeral formation rules (canonical form):\n\t1) Additive principle: if a symbol appears after a symbol of equal or greater value, its value is added.\n\t\t Example: VI = 5 + 1 = 6.\n\t2) Subtractive principle: if a symbol appears before a symbol of greater value, its value is subtracted.\n\t\t Subtraction is restricted to these pairs only:\n\t\t\t - I before V or X (IV=4, IX=9)\n\t\t\t - X before L or C (XL=40, XC=90)\n\t\t\t - C before D or M (CD=400, CM=900)\n\t3) Repetition limits:\n\t\t\t - V, L, D must not repeat.\n\t\t\t - I, X, C, M may repeat at most 3 times consecutively.\n\t4) Order of magnitude: symbols are arranged from highest to lowest value left-to-right, except for the allowed subtractive pairs.\n\nNumeric domain:\n\t- Standard Roman numerals are defined for integers N where 1 <= N <= 3999.\n\t- The output of integer-to-Roman conversion must be a canonical string consistent with the rules above.\n</background>\n\n<custom_data_types>\nN/A\n</custom_data_types>\n\n<function_signature>\n\t- Signature: to_numerals(N: int) -> str\n\t- Meaning: Convert integer N into its canonical RomanNumeralString.\n</function_signature>\n\n<function_details>\nFunction: to_numerals\n\tInputs:\n\t\t- N: integer.\n\tPreconditions:\n\t\t- N must satisfy 1 <= N <= 3999.\n\tOutput:\n\t\t- Returns a canonical RomanNumeralString representing N.\n\tPostconditions:\n\t\t- The returned string obeys all canonical formation rules.\n\t\t- from_numerals(to_numerals(N)) == N.\n\tAlgorithmic behavior (required at the level of the mapping, not implementation details):\n\t\t- The conversion must be consistent with a greedy decomposition over the following value-to-token list in descending order:\n\t\t\t\t1000->M, 900->CM, 500->D, 400->CD, 100->C, 90->XC, 50->L, 40->XL, 10->X, 9->IX, 5->V, 4->IV, 1->I.\n\t\t- At each step, append the token while its value fits into the remaining amount, subtracting accordingly, until remainder is 0.\n\tError handling:\n\t\t- If N is outside the domain [1, 3999], the function must raise an exception (e.g., ValueError) indicating out-of-range.\n\t\t- If N is not an integer type, the function must raise an exception (e.g., TypeError) indicating invalid input type.\n</function_details>\n\nLabeled spec expectations (freeform_spec=false):\n- <background>: high-level context, definitions, and rules.\n- <custom_data_types>: any custom types, encodings, invariants, examples.\n- <function_signature>: names, parameters, return types (as text), and meaning.\n- <function_details>: precise behavior, preconditions, postconditions, errors.\n\nTask:\n1) Identify the target function under test, its argument list, and its return type.\n2) Propose a standard *property-checking* function signature suitable for Hypothesis.\n   - It should accept the function under test (as a Callable) and the same inputs that function expects.\n   - It must return a boolean (True/False) indicating whether the property holds.\n3) Provide Hypothesis strategies to generate valid inputs for the property-checking function.\n   - Provide strategies for the *inputs* (not for the Callable itself).\n   - Respect any constraints/invariants from the spec.\n   - If some constraints are hard, propose assume()-style preconditions (as strings) or filtering.\n\nOutput requirements (STRICT):\n- Output MUST be valid JSON and NOTHING ELSE.\n- If the spec is insufficient or the inputs are impossible/unsupported to generate with Hypothesis, return:\n  {\"result\": null, \"explanation\": <string>}.\n- Otherwise return an object of this shape:\n  {\n    \"result\": {\n      \"function_under_test\": {\"name\": <string>, \"args\": [<string>...], \"returns\": <string>},\n      \"property_function\": {\"name\": <string>, \"typing\": <string>, \"args\": [<string>...], \"returns\": \"bool\"},\n      \"strategies\": [\n        {\"arg\": <string>, \"strategy\": <string>, \"notes\": <string|null>},\n        ...\n      ],\n      \"assumptions\": [<string>...],\n      \"imports\": [<string>...]\n    }\n  }\n- Provide at most 12 strategy entries.\n- The values in \"strategy\" should be Python expressions like 'st.integers(...)' as STRINGS (not full code).",
    "function_body_prompt": "You are implementing FOUR semantically different versions of a property-based test function.\nOutput MUST be valid JSON and NOTHING ELSE and match the provided schema.\n\nProblem specification:\n<background>\nThis problem concerns conversion between (1) positive integers and (2) their canonical Roman numeral string representations.\n\nRoman numerals use seven symbols with fixed values:\n\t- I=1, V=5, X=10, L=50, C=100, D=500, M=1000.\n\nNumeral formation rules (canonical form):\n\t1) Additive principle: if a symbol appears after a symbol of equal or greater value, its value is added.\n\t\t Example: VI = 5 + 1 = 6.\n\t2) Subtractive principle: if a symbol appears before a symbol of greater value, its value is subtracted.\n\t\t Subtraction is restricted to these pairs only:\n\t\t\t - I before V or X (IV=4, IX=9)\n\t\t\t - X before L or C (XL=40, XC=90)\n\t\t\t - C before D or M (CD=400, CM=900)\n\t3) Repetition limits:\n\t\t\t - V, L, D must not repeat.\n\t\t\t - I, X, C, M may repeat at most 3 times consecutively.\n\t4) Order of magnitude: symbols are arranged from highest to lowest value left-to-right, except for the allowed subtractive pairs.\n\nNumeric domain:\n\t- Standard Roman numerals are defined for integers N where 1 <= N <= 3999.\n\t- The output of integer-to-Roman conversion must be a canonical string consistent with the rules above.\n</background>\n\n<custom_data_types>\nN/A\n</custom_data_types>\n\n<function_signature>\n\t- Signature: to_numerals(N: int) -> str\n\t- Meaning: Convert integer N into its canonical RomanNumeralString.\n</function_signature>\n\n<function_details>\nFunction: to_numerals\n\tInputs:\n\t\t- N: integer.\n\tPreconditions:\n\t\t- N must satisfy 1 <= N <= 3999.\n\tOutput:\n\t\t- Returns a canonical RomanNumeralString representing N.\n\tPostconditions:\n\t\t- The returned string obeys all canonical formation rules.\n\t\t- from_numerals(to_numerals(N)) == N.\n\tAlgorithmic behavior (required at the level of the mapping, not implementation details):\n\t\t- The conversion must be consistent with a greedy decomposition over the following value-to-token list in descending order:\n\t\t\t\t1000->M, 900->CM, 500->D, 400->CD, 100->C, 90->XC, 50->L, 40->XL, 10->X, 9->IX, 5->V, 4->IV, 1->I.\n\t\t- At each step, append the token while its value fits into the remaining amount, subtracting accordingly, until remainder is 0.\n\tError handling:\n\t\t- If N is outside the domain [1, 3999], the function must raise an exception (e.g., ValueError) indicating out-of-range.\n\t\t- If N is not an integer type, the function must raise an exception (e.g., TypeError) indicating invalid input type.\n</function_details>\n\nProperties to test:\n1. For all integers N such that 1 <= N <= 3999, it must be true that from_numerals(to_numerals(N)) == N.\n2. For all integers N such that 1 <= N <= 3999, the return value of to_numerals(N) must be of type string.\n3. For all integers N such that 1 <= N <= 3999, every character in the string returned by to_numerals(N) must be one of 'I', 'V', 'X', 'L', 'C', 'D', 'M'.\n4. For all integers N such that 1 <= N <= 3999, the string returned by to_numerals(N) must not contain the substrings 'VV', 'LL', or 'DD'.\n5. For all integers N such that 1 <= N <= 3999, the string returned by to_numerals(N) must not contain the substrings 'IIII', 'XXXX', 'CCCC', or 'MMMM'.\n6. For all integers N such that 1 <= N <= 3999, if the string S = to_numerals(N) contains a symbol s1 immediately followed by a symbol s2 where value(s1) < value(s2), then the pair s1s2 must be one of 'IV', 'IX', 'XL', 'XC', 'CD', 'CM'.\n7. For all integers N such that 1 <= N <= 3999, the string returned by to_numerals(N) must not contain any of the following invalid two-symbol sequences: 'IL', 'IC', 'ID', 'IM', 'VX', 'VL', 'VC', 'VD', 'VM', 'LC', 'LD', 'LM', 'DM'.\n8. For specific integer values N in {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}, to_numerals(N) must return the corresponding canonical Roman numeral string (e.g., to_numerals(4) == 'IV', to_numerals(900) == 'CM').\n9. For all inputs N that are not of type integer (e.g., float, string, None, boolean), calling to_numerals(N) must raise a TypeError.\n10. For all integers N such that N < 1 (e.g., 0, -5), calling to_numerals(N) must raise a ValueError.\n11. For all integers N such that N > 3999 (e.g., 4000, 5000), calling to_numerals(N) must raise a ValueError.\n12. Calling to_numerals(1) must return the string 'I'.\n13. Calling to_numerals(3999) must return the string 'MMMCMXCIX'.\n14. For all integers N such that 1 <= N <= 3999, the length of the string returned by to_numerals(N) must be between 1 and 15, inclusive.\n15. For all integers N such that 1 <= N <= 3999, if the string S = to_numerals(N) is parsed into a sequence of canonical Roman numeral tokens (M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I), the sequence of integer values of these tokens must be non-increasing.\n\nFunction signature:\ndef test_function_pbt(N: Any) -> None:\n\nTask:\nGenerate FOUR semantically different implementations of the test function body.\nEach implementation MUST:\n1) Be syntactically valid Python code (indented with 4 spaces).\n2) Test some subset of the properties using assertions.\n3) Return None (Hypothesis requirement - no return statement needed).\n4) Print the input values at the start.\n5) Be SEMANTICALLY DIFFERENT from the others in meaningful ways:\n   - Test different subsets of properties\n   - Use different testing strategies (direct vs indirect)\n   - Check different edge cases\n   - Use different assertion styles\n   - Make different assumptions about valid inputs\n\nThe differences should be significant enough that when tested with the same\nHypothesis strategy, the implementations may produce DIFFERENT results (pass/fail).\n\nImportant formatting:\n- Return ONLY the function body code (NOT the 'def' line).\n- Use exactly 4 spaces for indentation.\n- Each implementation should be complete and executable.\n- Do NOT use placeholder comments like '# ... rest of implementation'.\n\nReturn a JSON object with:\n{\"implementations\": [\n  {\"body\": <string>, \"description\": <string>, \"imports\": [<strings>]},\n  ... (4 total)\n]}"
  },
  "responses": {
    "properties": {
      "raw": "{\n  \"result\": [\n    \"For all integers N such that 1 <= N <= 3999, it must be true that from_numerals(to_numerals(N)) == N.\",\n    \"For all integers N such that 1 <= N <= 3999, the return value of to_numerals(N) must be of type string.\",\n    \"For all integers N such that 1 <= N <= 3999, every character in the string returned by to_numerals(N) must be one of 'I', 'V', 'X', 'L', 'C', 'D', 'M'.\",\n    \"For all integers N such that 1 <= N <= 3999, the string returned by to_numerals(N) must not contain the substrings 'VV', 'LL', or 'DD'.\",\n    \"For all integers N such that 1 <= N <= 3999, the string returned by to_numerals(N) must not contain the substrings 'IIII', 'XXXX', 'CCCC', or 'MMMM'.\",\n    \"For all integers N such that 1 <= N <= 3999, if the string S = to_numerals(N) contains a symbol s1 immediately followed by a symbol s2 where value(s1) < value(s2), then the pair s1s2 must be one of 'IV', 'IX', 'XL', 'XC', 'CD', 'CM'.\",\n    \"For all integers N such that 1 <= N <= 3999, the string returned by to_numerals(N) must not contain any of the following invalid two-symbol sequences: 'IL', 'IC', 'ID', 'IM', 'VX', 'VL', 'VC', 'VD', 'VM', 'LC', 'LD', 'LM', 'DM'.\",\n    \"For specific integer values N in {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}, to_numerals(N) must return the corresponding canonical Roman numeral string (e.g., to_numerals(4) == 'IV', to_numerals(900) == 'CM').\",\n    \"For all inputs N that are not of type integer (e.g., float, string, None, boolean), calling to_numerals(N) must raise a TypeError.\",\n    \"For all integers N such that N < 1 (e.g., 0, -5), calling to_numerals(N) must raise a ValueError.\",\n    \"For all integers N such that N > 3999 (e.g., 4000, 5000), calling to_numerals(N) must raise a ValueError.\",\n    \"Calling to_numerals(1) must return the string 'I'.\",\n    \"Calling to_numerals(3999) must return the string 'MMMCMXCIX'.\",\n    \"For all integers N such that 1 <= N <= 3999, the length of the string returned by to_numerals(N) must be between 1 and 15, inclusive.\",\n    \"For all integers N such that 1 <= N <= 3999, if the string S = to_numerals(N) is parsed into a sequence of canonical Roman numeral tokens (M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I), the sequence of integer values of these tokens must be non-increasing.\"\n  ],\n  \"explanation\": null\n}",
      "parsed": {
        "result": [
          "For all integers N such that 1 <= N <= 3999, it must be true that from_numerals(to_numerals(N)) == N.",
          "For all integers N such that 1 <= N <= 3999, the return value of to_numerals(N) must be of type string.",
          "For all integers N such that 1 <= N <= 3999, every character in the string returned by to_numerals(N) must be one of 'I', 'V', 'X', 'L', 'C', 'D', 'M'.",
          "For all integers N such that 1 <= N <= 3999, the string returned by to_numerals(N) must not contain the substrings 'VV', 'LL', or 'DD'.",
          "For all integers N such that 1 <= N <= 3999, the string returned by to_numerals(N) must not contain the substrings 'IIII', 'XXXX', 'CCCC', or 'MMMM'.",
          "For all integers N such that 1 <= N <= 3999, if the string S = to_numerals(N) contains a symbol s1 immediately followed by a symbol s2 where value(s1) < value(s2), then the pair s1s2 must be one of 'IV', 'IX', 'XL', 'XC', 'CD', 'CM'.",
          "For all integers N such that 1 <= N <= 3999, the string returned by to_numerals(N) must not contain any of the following invalid two-symbol sequences: 'IL', 'IC', 'ID', 'IM', 'VX', 'VL', 'VC', 'VD', 'VM', 'LC', 'LD', 'LM', 'DM'.",
          "For specific integer values N in {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}, to_numerals(N) must return the corresponding canonical Roman numeral string (e.g., to_numerals(4) == 'IV', to_numerals(900) == 'CM').",
          "For all inputs N that are not of type integer (e.g., float, string, None, boolean), calling to_numerals(N) must raise a TypeError.",
          "For all integers N such that N < 1 (e.g., 0, -5), calling to_numerals(N) must raise a ValueError.",
          "For all integers N such that N > 3999 (e.g., 4000, 5000), calling to_numerals(N) must raise a ValueError.",
          "Calling to_numerals(1) must return the string 'I'.",
          "Calling to_numerals(3999) must return the string 'MMMCMXCIX'.",
          "For all integers N such that 1 <= N <= 3999, the length of the string returned by to_numerals(N) must be between 1 and 15, inclusive.",
          "For all integers N such that 1 <= N <= 3999, if the string S = to_numerals(N) is parsed into a sequence of canonical Roman numeral tokens (M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I), the sequence of integer values of these tokens must be non-increasing."
        ],
        "explanation": null
      },
      "error": null
    },
    "pbt_signature": {
      "raw": "{\n  \"parameters\": [\n    {\n      \"name\": \"N\",\n      \"type_hint\": \"Any\"\n    }\n  ],\n  \"strategies\": [\n    {\n      \"param_name\": \"N\",\n      \"strategy\": \"st.one_of(st.integers(min_value=1, max_value=3999), st.integers(max_value=0), st.integers(min_value=4000), st.floats(allow_nan=false, allow_infinity=false), st.text(), st.none(), st.booleans())\",\n      \"notes\": \"Generates valid integers (1-3999) for core functionality tests, out-of-range integers (<1, >3999) for ValueError tests, and various non-integer types (float, string, None, boolean) for TypeError tests. This comprehensive strategy allows a single test function to cover all specified properties, including error handling.\"\n    }\n  ]\n}",
      "parsed": {
        "parameters": [
          {
            "name": "N",
            "type_hint": "Any"
          }
        ],
        "strategies": [
          {
            "param_name": "N",
            "strategy": "st.one_of(st.integers(min_value=1, max_value=3999), st.integers(max_value=0), st.integers(min_value=4000), st.floats(allow_nan=false, allow_infinity=false), st.text(), st.none(), st.booleans())",
            "notes": "Generates valid integers (1-3999) for core functionality tests, out-of-range integers (<1, >3999) for ValueError tests, and various non-integer types (float, string, None, boolean) for TypeError tests. This comprehensive strategy allows a single test function to cover all specified properties, including error handling."
          }
        ]
      },
      "error": null
    },
    "function_body": {
      "raw": "{\n  \"implementations\": [\n    {\n      \"body\": \"    print(f\\\"Testing N={N}\\\")\\n    result = to_numerals(N)\\n\\n    # Property 2: Type check\\n    assert isinstance(result, str), f\\\"Expected string, got {type(result)} for N={N}\\\"\\n\\n    # Property 1: Roundtrip\\n    assert from_numerals(result) == N, f\\\"Roundtrip failed: from_numerals({result}) != {N}\\\"\\n\\n    # Property 3: Valid characters\\n    assert all(c in ROMAN_SYMBOLS for c in result), f\\\"Invalid characters in {result} for N={N}\\\"\\n\\n    # Property 14: Length constraint\\n    assert 1 <= len(result) <= 15, f\\\"Length out of range for {result} (N={N})\\\"\\n\\n    # Property 4: No 'VV', 'LL', 'DD'\\n    assert 'VV' not in result and 'LL' not in result and 'DD' not in result, f\\\"Forbidden repetition found in {result} (N={N})\\\"\\n\\n    # Property 5: No 'IIII', 'XXXX', 'CCCC', 'MMMM'\\n    assert 'IIII' not in result and 'XXXX' not in result and 'CCCC' not in result and 'MMMM' not in result, f\\\"Forbidden repetition found in {result} (N={N})\\\"\\n\\n    # Property 6 & 7: Subtractive pairs only and no invalid two-symbol sequences\\n    INVALID_TWO_SYMBOLS = {'IL', 'IC', 'ID', 'IM', 'VX', 'VL', 'VC', 'VD', 'VM', 'LC', 'LD', 'LM', 'DM'}\\n    ALLOWED_SUBTRACTIVE_PAIRS = {'IV', 'IX', 'XL', 'XC', 'CD', 'CM'}\\n    for i in range(len(result) - 1):\\n        pair = result[i:i+2]\\n        if pair in INVALID_TWO_SYMBOLS:\\n            assert False, f\\\"Invalid two-symbol sequence '{pair}' found in {result} (N={N})\\\"\\n        s1_val = ROMAN_MAP_VALUES.get(result[i], 0)\\n        s2_val = ROMAN_MAP_VALUES.get(result[i+1], 0)\\n        if s1_val < s2_val:\\n            assert pair in ALLOWED_SUBTRACTIVE_PAIRS, f\\\"Invalid subtractive pair '{pair}' found in {result} (N={N})\\\"\\n\\n    # Property 15: Token values non-increasing\\n    token_values = get_token_values(result)\\n    for i in range(len(token_values) - 1):\\n        assert token_values[i] >= token_values[i+1], f\\\"Token values not non-increasing in {result} (N={N})\\\"\\n\\n    # Property 12 & 13: Specific edge values (if N is 1 or 3999)\\n    if N == 1:\\n        assert result == 'I', f\\\"to_numerals(1) expected 'I', got '{result}'\\\"\\n    if N == 3999:\\n        assert result == 'MMMCMXCIX', f\\\"to_numerals(3999) expected 'MMMCMXCIX', got '{result}'\\\"\",\n      \"description\": \"This implementation performs a comprehensive check for valid inputs, covering roundtrip conversion, type, character validity, length, repetition limits, and specific invalid subtractive pairs. It also verifies the non-increasing order of token values, ensuring adherence to the greedy decomposition algorithm.\",\n      \"imports\": [\n        \"ROMAN_MAP_VALUES = {\\n    'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000,\\n    'IV': 4, 'IX': 9, 'XL': 40, 'XC': 90, 'CD': 400, 'CM': 900\\n}\",\n        \"ROMAN_SYMBOLS = set('IVXLCDM')\",\n        \"ROMAN_TOKEN_VALUES = [\\n    (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'),\\n    (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\\n]\",\n        \"def from_numerals(roman_numeral_string: str) -> int:\\n    if not isinstance(roman_numeral_string, str):\\n        raise TypeError(\\\"Input must be a string.\\\")\\n    if not roman_numeral_string:\\n        raise ValueError(\\\"Input string cannot be empty.\\\")\\n    total = 0\\n    i = 0\\n    while i < len(roman_numeral_string):\\n        if i + 1 < len(roman_numeral_string):\\n            two_char_symbol = roman_numeral_string[i:i+2]\\n            if two_char_symbol in ROMAN_MAP_VALUES and len(two_char_symbol) == 2:\\n                total += ROMAN_MAP_VALUES[two_char_symbol]\\n                i += 2\\n                continue\\n        one_char_symbol = roman_numeral_string[i]\\n        if one_char_symbol in ROMAN_MAP_VALUES:\\n            total += ROMAN_MAP_VALUES[one_char_symbol]\\n            i += 1\\n        else:\\n            raise ValueError(f\\\"Invalid Roman numeral symbol: {one_char_symbol}\\\")\\n    return total\",\n        \"def get_token_values(roman_string: str) -> list[int]:\\n    values = []\\n    i = 0\\n    while i < len(roman_string):\\n        matched = False\\n        for val, token in ROMAN_TOKEN_VALUES:\\n            if roman_string.startswith(token, i):\\n                values.append(val)\\n                i += len(token)\\n                matched = True\\n                break\\n        if not matched:\\n            raise ValueError(f\\\"Could not parse token at index {i} in {roman_string}\\\")\\n    return values\"\n      ]\n    },\n    {\n      \"body\": \"    print(f\\\"Testing N={N}\\\")\\n\\n    # Property 9: TypeError for non-integer N\\n    if not isinstance(N, int):\\n        try:\\n            to_numerals(N)\\n            assert False, f\\\"Expected TypeError for non-integer N={N}, but no exception was raised.\\\"\\n        except TypeError:\\n            pass # Expected\\n        except Exception as e:\\n            assert False, f\\\"Expected TypeError for non-integer N={N}, but got {type(e).__name__}: {e}\\\"\\n        return # Skip further checks for invalid types\\n\\n    # Properties 10 & 11: ValueError for out-of-range N\\n    if not (1 <= N <= 3999):\\n        try:\\n            to_numerals(N)\\n            assert False, f\\\"Expected ValueError for out-of-range N={N}, but no exception was raised.\\\"\\n        except ValueError:\\n            pass # Expected\\n        except Exception as e:\\n            assert False, f\\\"Expected ValueError for out-of-range N={N}, but got {type(e).__name__}: {e}\\\"\\n        return # Skip further checks for out-of-range values\\n\\n    # If N is a valid integer within range, check specific values (Property 8)\\n    result = to_numerals(N)\\n    EXPECTED_VALUES = {\\n        1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC',\\n        100: 'C', 400: 'CD', 500: 'D', 900: 'CM', 1000: 'M'\\n    }\\n    if N in EXPECTED_VALUES:\\n        assert result == EXPECTED_VALUES[N], f\\\"to_numerals({N}) expected '{EXPECTED_VALUES[N]}', got '{result}'\\\"\",\n      \"description\": \"This implementation focuses primarily on error handling for invalid input types and out-of-range integer values, asserting that the correct exceptions (TypeError or ValueError) are raised. It also includes direct assertions for specific, well-known Roman numeral conversions.\",\n      \"imports\": [\n        \"ROMAN_MAP_VALUES = {\\n    'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000,\\n    'IV': 4, 'IX': 9, 'XL': 40, 'XC': 90, 'CD': 400, 'CM': 900\\n}\",\n        \"ROMAN_SYMBOLS = set('IVXLCDM')\",\n        \"ROMAN_TOKEN_VALUES = [\\n    (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'),\\n    (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\\n]\",\n        \"def from_numerals(roman_numeral_string: str) -> int:\\n    if not isinstance(roman_numeral_string, str):\\n        raise TypeError(\\\"Input must be a string.\\\")\\n    if not roman_numeral_string:\\n        raise ValueError(\\\"Input string cannot be empty.\\\")\\n    total = 0\\n    i = 0\\n    while i < len(roman_numeral_string):\\n        if i + 1 < len(roman_numeral_string):\\n            two_char_symbol = roman_numeral_string[i:i+2]\\n            if two_char_symbol in ROMAN_MAP_VALUES and len(two_char_symbol) == 2:\\n                total += ROMAN_MAP_VALUES[two_char_symbol]\\n                i += 2\\n                continue\\n        one_char_symbol = roman_numeral_string[i]\\n        if one_char_symbol in ROMAN_MAP_VALUES:\\n            total += ROMAN_MAP_VALUES[one_char_symbol]\\n            i += 1\\n        else:\\n            raise ValueError(f\\\"Invalid Roman numeral symbol: {one_char_symbol}\\\")\\n    return total\",\n        \"def get_token_values(roman_string: str) -> list[int]:\\n    values = []\\n    i = 0\\n    while i < len(roman_string):\\n        matched = False\\n        for val, token in ROMAN_TOKEN_VALUES:\\n            if roman_string.startswith(token, i):\\n                values.append(val)\\n                i += len(token)\\n                matched = True\\n                break\\n        if not matched:\\n            raise ValueError(f\\\"Could not parse token at index {i} in {roman_string}\\\")\\n    return values\",\n        \"EXPECTED_VALUES = {\\n        1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC',\\n        100: 'C', 400: 'CD', 500: 'D', 900: 'CM', 1000: 'M'\\n    }\"\n      ]\n    },\n    {\n      \"body\": \"    print(f\\\"Testing N={N}\\\")\\n    result = to_numerals(N)\\n\\n    # Property 2: Type check\\n    assert isinstance(result, str), f\\\"Expected string, got {type(result)} for N={N}\\\"\\n\\n    # Property 3: Valid characters\\n    assert all(c in ROMAN_SYMBOLS for c in result), f\\\"Invalid characters in {result} for N={N}\\\"\\n\\n    # Property 14: Length constraint\\n    assert 1 <= len(result) <= 15, f\\\"Length out of range for {result} (N={N})\\\"\\n\\n    # Property 4: No 'VV', 'LL', 'DD'\\n    assert 'VV' not in result, f\\\"Forbidden 'VV' found in {result} (N={N})\\\"\\n    assert 'LL' not in result, f\\\"Forbidden 'LL' found in {result} (N={N})\\\"\\n    assert 'DD' not in result, f\\\"Forbidden 'DD' found in {result} (N={N})\\\"\\n\\n    # Property 5: No 'IIII', 'XXXX', 'CCCC', 'MMMM'\\n    assert 'IIII' not in result, f\\\"Forbidden 'IIII' found in {result} (N={N})\\\"\\n    assert 'XXXX' not in result, f\\\"Forbidden 'XXXX' found in {result} (N={N})\\\"\\n    assert 'CCCC' not in result, f\\\"Forbidden 'CCCC' found in {result} (N={N})\\\"\\n    assert 'MMMM' not in result, f\\\"Forbidden 'MMMM' found in {result} (N={N})\\\"\\n\\n    # Property 7: No invalid two-symbol sequences\\n    INVALID_TWO_SYMBOLS = {'IL', 'IC', 'ID', 'IM', 'VX', 'VL', 'VC', 'VD', 'VM', 'LC', 'LD', 'LM', 'DM'}\\n    for invalid_pair in INVALID_TWO_SYMBOLS:\\n        assert invalid_pair not in result, f\\\"Invalid sequence '{invalid_pair}' found in {result} (N={N})\\\"\\n\\n    # Property 6: Subtractive principle check (s1 < s2 implies allowed pair)\\n    ALLOWED_SUBTRACTIVE_PAIRS = {'IV', 'IX', 'XL', 'XC', 'CD', 'CM'}\\n    for i in range(len(result) - 1):\\n        s1 = result[i]\\n        s2 = result[i+1]\\n        val1 = ROMAN_MAP_VALUES.get(s1, 0)\\n        val2 = ROMAN_MAP_VALUES.get(s2, 0)\\n        if val1 < val2:\\n            pair = s1 + s2\\n            assert pair in ALLOWED_SUBTRACTIVE_PAIRS, f\\\"Invalid subtractive pair '{pair}' found in {result} (N={N})\\\"\",\n      \"description\": \"This implementation emphasizes structural correctness of the Roman numeral string, performing extensive substring checks to ensure adherence to repetition limits (e.g., no 'VV', 'IIII') and the absence of invalid two-symbol sequences. It also verifies that any subtractive pairs are among the allowed canonical forms.\",\n      \"imports\": [\n        \"ROMAN_MAP_VALUES = {\\n    'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000,\\n    'IV': 4, 'IX': 9, 'XL': 40, 'XC': 90, 'CD': 400, 'CM': 900\\n}\",\n        \"ROMAN_SYMBOLS = set('IVXLCDM')\",\n        \"ROMAN_TOKEN_VALUES = [\\n    (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'),\\n    (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\\n]\",\n        \"def from_numerals(roman_numeral_string: str) -> int:\\n    if not isinstance(roman_numeral_string, str):\\n        raise TypeError(\\\"Input must be a string.\\\")\\n    if not roman_numeral_string:\\n        raise ValueError(\\\"Input string cannot be empty.\\\")\\n    total = 0\\n    i = 0\\n    while i < len(roman_numeral_string):\\n        if i + 1 < len(roman_numeral_string):\\n            two_char_symbol = roman_numeral_string[i:i+2]\\n            if two_char_symbol in ROMAN_MAP_VALUES and len(two_char_symbol) == 2:\\n                total += ROMAN_MAP_VALUES[two_char_symbol]\\n                i += 2\\n                continue\\n        one_char_symbol = roman_numeral_string[i]\\n        if one_char_symbol in ROMAN_MAP_VALUES:\\n            total += ROMAN_MAP_VALUES[one_char_symbol]\\n            i += 1\\n        else:\\n            raise ValueError(f\\\"Invalid Roman numeral symbol: {one_char_symbol}\\\")\\n    return total\",\n        \"def get_token_values(roman_string: str) -> list[int]:\\n    values = []\\n    i = 0\\n    while i < len(roman_string):\\n        matched = False\\n        for val, token in ROMAN_TOKEN_VALUES:\\n            if roman_string.startswith(token, i):\\n                values.append(val)\\n                i += len(token)\\n                matched = True\\n                break\\n        if not matched:\\n            raise ValueError(f\\\"Could not parse token at index {i} in {roman_string}\\\")\\n    return values\"\n      ]\n    },\n    {\n      \"body\": \"    print(f\\\"Testing N={N}\\\")\\n    result = to_numerals(N)\\n\\n    # Property 2: Type check\\n    assert isinstance(result, str), f\\\"Expected string, got {type(result)} for N={N}\\\"\\n\\n    # Property 3: Valid characters (basic check)\\n    assert all(c in ROMAN_SYMBOLS for c in result), f\\\"Invalid characters in {result} for N={N}\\\"\\n\\n    # Property 1: Roundtrip is the primary check\\n    assert from_numerals(result) == N, f\\\"Roundtrip failed: from_numerals({result}) != {N}\\\"\\n\\n    # Property 15: Token values non-increasing (checks greedy decomposition)\\n    token_values = get_token_values(result)\\n    assert len(token_values) > 0, f\\\"No tokens parsed for {result} (N={N})\\\"\\n    for i in range(len(token_values) - 1):\\n        assert token_values[i] >= token_values[i+1], f\\\"Token values not non-increasing in {result} (N={N})\\\"\\n\\n    # Also check that the sum of token values equals N, which is implicitly covered by roundtrip,\\n    # but can be an additional check for the token parsing logic itself.\\n    assert sum(token_values) == N, f\\\"Sum of parsed token values ({sum(token_values)}) does not equal N ({N}) for {result}\\\"\",\n      \"description\": \"This implementation prioritizes the core functional correctness by asserting the roundtrip property (from_numerals(to_numerals(N)) == N). It also strongly verifies the algorithmic behavior by checking that the parsed token values are strictly non-increasing, reflecting the greedy decomposition requirement.\",\n      \"imports\": [\n        \"ROMAN_MAP_VALUES = {\\n    'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000,\\n    'IV': 4, 'IX': 9, 'XL': 40, 'XC': 90, 'CD': 400, 'CM': 900\\n}\",\n        \"ROMAN_SYMBOLS = set('IVXLCDM')\",\n        \"ROMAN_TOKEN_VALUES = [\\n    (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'),\\n    (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\\n]\",\n        \"def from_numerals(roman_numeral_string: str) -> int:\\n    if not isinstance(roman_numeral_string, str):\\n        raise TypeError(\\\"Input must be a string.\\\")\\n    if not roman_numeral_string:\\n        raise ValueError(\\\"Input string cannot be empty.\\\")\\n    total = 0\\n    i = 0\\n    while i < len(roman_numeral_string):\\n        if i + 1 < len(roman_numeral_string):\\n            two_char_symbol = roman_numeral_string[i:i+2]\\n            if two_char_symbol in ROMAN_MAP_VALUES and len(two_char_symbol) == 2:\\n                total += ROMAN_MAP_VALUES[two_char_symbol]\\n                i += 2\\n                continue\\n        one_char_symbol = roman_numeral_string[i]\\n        if one_char_symbol in ROMAN_MAP_VALUES:\\n            total += ROMAN_MAP_VALUES[one_char_symbol]\\n            i += 1\\n        else:\\n            raise ValueError(f\\\"Invalid Roman numeral symbol: {one_char_symbol}\\\")\\n    return total\",\n        \"def get_token_values(roman_string: str) -> list[int]:\\n    values = []\\n    i = 0\\n    while i < len(roman_string):\\n        matched = False\\n        for val, token in ROMAN_TOKEN_VALUES:\\n            if roman_string.startswith(token, i):\\n                values.append(val)\\n                i += len(token)\\n                matched = True\\n                break\\n        if not matched:\\n            raise ValueError(f\\\"Could not parse token at index {i} in {roman_string}\\\")\\n    return values\"\n      ]\n    }\n  ]\n}",
      "parsed": {
        "implementations": [
          {
            "body": "    print(f\"Testing N={N}\")\n    result = to_numerals(N)\n\n    # Property 2: Type check\n    assert isinstance(result, str), f\"Expected string, got {type(result)} for N={N}\"\n\n    # Property 1: Roundtrip\n    assert from_numerals(result) == N, f\"Roundtrip failed: from_numerals({result}) != {N}\"\n\n    # Property 3: Valid characters\n    assert all(c in ROMAN_SYMBOLS for c in result), f\"Invalid characters in {result} for N={N}\"\n\n    # Property 14: Length constraint\n    assert 1 <= len(result) <= 15, f\"Length out of range for {result} (N={N})\"\n\n    # Property 4: No 'VV', 'LL', 'DD'\n    assert 'VV' not in result and 'LL' not in result and 'DD' not in result, f\"Forbidden repetition found in {result} (N={N})\"\n\n    # Property 5: No 'IIII', 'XXXX', 'CCCC', 'MMMM'\n    assert 'IIII' not in result and 'XXXX' not in result and 'CCCC' not in result and 'MMMM' not in result, f\"Forbidden repetition found in {result} (N={N})\"\n\n    # Property 6 & 7: Subtractive pairs only and no invalid two-symbol sequences\n    INVALID_TWO_SYMBOLS = {'IL', 'IC', 'ID', 'IM', 'VX', 'VL', 'VC', 'VD', 'VM', 'LC', 'LD', 'LM', 'DM'}\n    ALLOWED_SUBTRACTIVE_PAIRS = {'IV', 'IX', 'XL', 'XC', 'CD', 'CM'}\n    for i in range(len(result) - 1):\n        pair = result[i:i+2]\n        if pair in INVALID_TWO_SYMBOLS:\n            assert False, f\"Invalid two-symbol sequence '{pair}' found in {result} (N={N})\"\n        s1_val = ROMAN_MAP_VALUES.get(result[i], 0)\n        s2_val = ROMAN_MAP_VALUES.get(result[i+1], 0)\n        if s1_val < s2_val:\n            assert pair in ALLOWED_SUBTRACTIVE_PAIRS, f\"Invalid subtractive pair '{pair}' found in {result} (N={N})\"\n\n    # Property 15: Token values non-increasing\n    token_values = get_token_values(result)\n    for i in range(len(token_values) - 1):\n        assert token_values[i] >= token_values[i+1], f\"Token values not non-increasing in {result} (N={N})\"\n\n    # Property 12 & 13: Specific edge values (if N is 1 or 3999)\n    if N == 1:\n        assert result == 'I', f\"to_numerals(1) expected 'I', got '{result}'\"\n    if N == 3999:\n        assert result == 'MMMCMXCIX', f\"to_numerals(3999) expected 'MMMCMXCIX', got '{result}'\"",
            "description": "This implementation performs a comprehensive check for valid inputs, covering roundtrip conversion, type, character validity, length, repetition limits, and specific invalid subtractive pairs. It also verifies the non-increasing order of token values, ensuring adherence to the greedy decomposition algorithm.",
            "imports": [
              "ROMAN_MAP_VALUES = {\n    'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000,\n    'IV': 4, 'IX': 9, 'XL': 40, 'XC': 90, 'CD': 400, 'CM': 900\n}",
              "ROMAN_SYMBOLS = set('IVXLCDM')",
              "ROMAN_TOKEN_VALUES = [\n    (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'),\n    (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n]",
              "def from_numerals(roman_numeral_string: str) -> int:\n    if not isinstance(roman_numeral_string, str):\n        raise TypeError(\"Input must be a string.\")\n    if not roman_numeral_string:\n        raise ValueError(\"Input string cannot be empty.\")\n    total = 0\n    i = 0\n    while i < len(roman_numeral_string):\n        if i + 1 < len(roman_numeral_string):\n            two_char_symbol = roman_numeral_string[i:i+2]\n            if two_char_symbol in ROMAN_MAP_VALUES and len(two_char_symbol) == 2:\n                total += ROMAN_MAP_VALUES[two_char_symbol]\n                i += 2\n                continue\n        one_char_symbol = roman_numeral_string[i]\n        if one_char_symbol in ROMAN_MAP_VALUES:\n            total += ROMAN_MAP_VALUES[one_char_symbol]\n            i += 1\n        else:\n            raise ValueError(f\"Invalid Roman numeral symbol: {one_char_symbol}\")\n    return total",
              "def get_token_values(roman_string: str) -> list[int]:\n    values = []\n    i = 0\n    while i < len(roman_string):\n        matched = False\n        for val, token in ROMAN_TOKEN_VALUES:\n            if roman_string.startswith(token, i):\n                values.append(val)\n                i += len(token)\n                matched = True\n                break\n        if not matched:\n            raise ValueError(f\"Could not parse token at index {i} in {roman_string}\")\n    return values"
            ],
            "index": 1
          },
          {
            "body": "    print(f\"Testing N={N}\")\n\n    # Property 9: TypeError for non-integer N\n    if not isinstance(N, int):\n        try:\n            to_numerals(N)\n            assert False, f\"Expected TypeError for non-integer N={N}, but no exception was raised.\"\n        except TypeError:\n            pass # Expected\n        except Exception as e:\n            assert False, f\"Expected TypeError for non-integer N={N}, but got {type(e).__name__}: {e}\"\n        return # Skip further checks for invalid types\n\n    # Properties 10 & 11: ValueError for out-of-range N\n    if not (1 <= N <= 3999):\n        try:\n            to_numerals(N)\n            assert False, f\"Expected ValueError for out-of-range N={N}, but no exception was raised.\"\n        except ValueError:\n            pass # Expected\n        except Exception as e:\n            assert False, f\"Expected ValueError for out-of-range N={N}, but got {type(e).__name__}: {e}\"\n        return # Skip further checks for out-of-range values\n\n    # If N is a valid integer within range, check specific values (Property 8)\n    result = to_numerals(N)\n    EXPECTED_VALUES = {\n        1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC',\n        100: 'C', 400: 'CD', 500: 'D', 900: 'CM', 1000: 'M'\n    }\n    if N in EXPECTED_VALUES:\n        assert result == EXPECTED_VALUES[N], f\"to_numerals({N}) expected '{EXPECTED_VALUES[N]}', got '{result}'\"",
            "description": "This implementation focuses primarily on error handling for invalid input types and out-of-range integer values, asserting that the correct exceptions (TypeError or ValueError) are raised. It also includes direct assertions for specific, well-known Roman numeral conversions.",
            "imports": [
              "ROMAN_MAP_VALUES = {\n    'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000,\n    'IV': 4, 'IX': 9, 'XL': 40, 'XC': 90, 'CD': 400, 'CM': 900\n}",
              "ROMAN_SYMBOLS = set('IVXLCDM')",
              "ROMAN_TOKEN_VALUES = [\n    (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'),\n    (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n]",
              "def from_numerals(roman_numeral_string: str) -> int:\n    if not isinstance(roman_numeral_string, str):\n        raise TypeError(\"Input must be a string.\")\n    if not roman_numeral_string:\n        raise ValueError(\"Input string cannot be empty.\")\n    total = 0\n    i = 0\n    while i < len(roman_numeral_string):\n        if i + 1 < len(roman_numeral_string):\n            two_char_symbol = roman_numeral_string[i:i+2]\n            if two_char_symbol in ROMAN_MAP_VALUES and len(two_char_symbol) == 2:\n                total += ROMAN_MAP_VALUES[two_char_symbol]\n                i += 2\n                continue\n        one_char_symbol = roman_numeral_string[i]\n        if one_char_symbol in ROMAN_MAP_VALUES:\n            total += ROMAN_MAP_VALUES[one_char_symbol]\n            i += 1\n        else:\n            raise ValueError(f\"Invalid Roman numeral symbol: {one_char_symbol}\")\n    return total",
              "def get_token_values(roman_string: str) -> list[int]:\n    values = []\n    i = 0\n    while i < len(roman_string):\n        matched = False\n        for val, token in ROMAN_TOKEN_VALUES:\n            if roman_string.startswith(token, i):\n                values.append(val)\n                i += len(token)\n                matched = True\n                break\n        if not matched:\n            raise ValueError(f\"Could not parse token at index {i} in {roman_string}\")\n    return values",
              "EXPECTED_VALUES = {\n        1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC',\n        100: 'C', 400: 'CD', 500: 'D', 900: 'CM', 1000: 'M'\n    }"
            ],
            "index": 2
          },
          {
            "body": "    print(f\"Testing N={N}\")\n    result = to_numerals(N)\n\n    # Property 2: Type check\n    assert isinstance(result, str), f\"Expected string, got {type(result)} for N={N}\"\n\n    # Property 3: Valid characters\n    assert all(c in ROMAN_SYMBOLS for c in result), f\"Invalid characters in {result} for N={N}\"\n\n    # Property 14: Length constraint\n    assert 1 <= len(result) <= 15, f\"Length out of range for {result} (N={N})\"\n\n    # Property 4: No 'VV', 'LL', 'DD'\n    assert 'VV' not in result, f\"Forbidden 'VV' found in {result} (N={N})\"\n    assert 'LL' not in result, f\"Forbidden 'LL' found in {result} (N={N})\"\n    assert 'DD' not in result, f\"Forbidden 'DD' found in {result} (N={N})\"\n\n    # Property 5: No 'IIII', 'XXXX', 'CCCC', 'MMMM'\n    assert 'IIII' not in result, f\"Forbidden 'IIII' found in {result} (N={N})\"\n    assert 'XXXX' not in result, f\"Forbidden 'XXXX' found in {result} (N={N})\"\n    assert 'CCCC' not in result, f\"Forbidden 'CCCC' found in {result} (N={N})\"\n    assert 'MMMM' not in result, f\"Forbidden 'MMMM' found in {result} (N={N})\"\n\n    # Property 7: No invalid two-symbol sequences\n    INVALID_TWO_SYMBOLS = {'IL', 'IC', 'ID', 'IM', 'VX', 'VL', 'VC', 'VD', 'VM', 'LC', 'LD', 'LM', 'DM'}\n    for invalid_pair in INVALID_TWO_SYMBOLS:\n        assert invalid_pair not in result, f\"Invalid sequence '{invalid_pair}' found in {result} (N={N})\"\n\n    # Property 6: Subtractive principle check (s1 < s2 implies allowed pair)\n    ALLOWED_SUBTRACTIVE_PAIRS = {'IV', 'IX', 'XL', 'XC', 'CD', 'CM'}\n    for i in range(len(result) - 1):\n        s1 = result[i]\n        s2 = result[i+1]\n        val1 = ROMAN_MAP_VALUES.get(s1, 0)\n        val2 = ROMAN_MAP_VALUES.get(s2, 0)\n        if val1 < val2:\n            pair = s1 + s2\n            assert pair in ALLOWED_SUBTRACTIVE_PAIRS, f\"Invalid subtractive pair '{pair}' found in {result} (N={N})\"",
            "description": "This implementation emphasizes structural correctness of the Roman numeral string, performing extensive substring checks to ensure adherence to repetition limits (e.g., no 'VV', 'IIII') and the absence of invalid two-symbol sequences. It also verifies that any subtractive pairs are among the allowed canonical forms.",
            "imports": [
              "ROMAN_MAP_VALUES = {\n    'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000,\n    'IV': 4, 'IX': 9, 'XL': 40, 'XC': 90, 'CD': 400, 'CM': 900\n}",
              "ROMAN_SYMBOLS = set('IVXLCDM')",
              "ROMAN_TOKEN_VALUES = [\n    (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'),\n    (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n]",
              "def from_numerals(roman_numeral_string: str) -> int:\n    if not isinstance(roman_numeral_string, str):\n        raise TypeError(\"Input must be a string.\")\n    if not roman_numeral_string:\n        raise ValueError(\"Input string cannot be empty.\")\n    total = 0\n    i = 0\n    while i < len(roman_numeral_string):\n        if i + 1 < len(roman_numeral_string):\n            two_char_symbol = roman_numeral_string[i:i+2]\n            if two_char_symbol in ROMAN_MAP_VALUES and len(two_char_symbol) == 2:\n                total += ROMAN_MAP_VALUES[two_char_symbol]\n                i += 2\n                continue\n        one_char_symbol = roman_numeral_string[i]\n        if one_char_symbol in ROMAN_MAP_VALUES:\n            total += ROMAN_MAP_VALUES[one_char_symbol]\n            i += 1\n        else:\n            raise ValueError(f\"Invalid Roman numeral symbol: {one_char_symbol}\")\n    return total",
              "def get_token_values(roman_string: str) -> list[int]:\n    values = []\n    i = 0\n    while i < len(roman_string):\n        matched = False\n        for val, token in ROMAN_TOKEN_VALUES:\n            if roman_string.startswith(token, i):\n                values.append(val)\n                i += len(token)\n                matched = True\n                break\n        if not matched:\n            raise ValueError(f\"Could not parse token at index {i} in {roman_string}\")\n    return values"
            ],
            "index": 3
          },
          {
            "body": "    print(f\"Testing N={N}\")\n    result = to_numerals(N)\n\n    # Property 2: Type check\n    assert isinstance(result, str), f\"Expected string, got {type(result)} for N={N}\"\n\n    # Property 3: Valid characters (basic check)\n    assert all(c in ROMAN_SYMBOLS for c in result), f\"Invalid characters in {result} for N={N}\"\n\n    # Property 1: Roundtrip is the primary check\n    assert from_numerals(result) == N, f\"Roundtrip failed: from_numerals({result}) != {N}\"\n\n    # Property 15: Token values non-increasing (checks greedy decomposition)\n    token_values = get_token_values(result)\n    assert len(token_values) > 0, f\"No tokens parsed for {result} (N={N})\"\n    for i in range(len(token_values) - 1):\n        assert token_values[i] >= token_values[i+1], f\"Token values not non-increasing in {result} (N={N})\"\n\n    # Also check that the sum of token values equals N, which is implicitly covered by roundtrip,\n    # but can be an additional check for the token parsing logic itself.\n    assert sum(token_values) == N, f\"Sum of parsed token values ({sum(token_values)}) does not equal N ({N}) for {result}\"",
            "description": "This implementation prioritizes the core functional correctness by asserting the roundtrip property (from_numerals(to_numerals(N)) == N). It also strongly verifies the algorithmic behavior by checking that the parsed token values are strictly non-increasing, reflecting the greedy decomposition requirement.",
            "imports": [
              "ROMAN_MAP_VALUES = {\n    'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000,\n    'IV': 4, 'IX': 9, 'XL': 40, 'XC': 90, 'CD': 400, 'CM': 900\n}",
              "ROMAN_SYMBOLS = set('IVXLCDM')",
              "ROMAN_TOKEN_VALUES = [\n    (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'),\n    (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n]",
              "def from_numerals(roman_numeral_string: str) -> int:\n    if not isinstance(roman_numeral_string, str):\n        raise TypeError(\"Input must be a string.\")\n    if not roman_numeral_string:\n        raise ValueError(\"Input string cannot be empty.\")\n    total = 0\n    i = 0\n    while i < len(roman_numeral_string):\n        if i + 1 < len(roman_numeral_string):\n            two_char_symbol = roman_numeral_string[i:i+2]\n            if two_char_symbol in ROMAN_MAP_VALUES and len(two_char_symbol) == 2:\n                total += ROMAN_MAP_VALUES[two_char_symbol]\n                i += 2\n                continue\n        one_char_symbol = roman_numeral_string[i]\n        if one_char_symbol in ROMAN_MAP_VALUES:\n            total += ROMAN_MAP_VALUES[one_char_symbol]\n            i += 1\n        else:\n            raise ValueError(f\"Invalid Roman numeral symbol: {one_char_symbol}\")\n    return total",
              "def get_token_values(roman_string: str) -> list[int]:\n    values = []\n    i = 0\n    while i < len(roman_string):\n        matched = False\n        for val, token in ROMAN_TOKEN_VALUES:\n            if roman_string.startswith(token, i):\n                values.append(val)\n                i += len(token)\n                matched = True\n                break\n        if not matched:\n            raise ValueError(f\"Could not parse token at index {i} in {roman_string}\")\n    return values"
            ],
            "index": 4
          }
        ]
      },
      "error": null,
      "generated_functions": [
        {
          "index": 1,
          "function_name": "test_function_pbt_1",
          "description": "This implementation performs a comprehensive check for valid inputs, covering roundtrip conversion, type, character validity, length, repetition limits, and specific invalid subtractive pairs. It also verifies the non-increasing order of token values, ensuring adherence to the greedy decomposition algorithm.",
          "code": "def test_function_pbt_1(N: Any) -> None:\n    \"\"\"Property-based test function generated by LLM.\n\n    This implementation performs a comprehensive check for valid inputs, covering roundtrip conversion, type, character validity, length, repetition limits, and specific invalid subtractive pairs. It also verifies the non-increasing order of token values, ensuring adherence to the greedy decomposition algorithm.\n    \"\"\"\n    print(f\"Testing N={N}\")\n    result = to_numerals(N)\n\n    # Property 2: Type check\n    assert isinstance(result, str), f\"Expected string, got {type(result)} for N={N}\"\n\n    # Property 1: Roundtrip\n    assert from_numerals(result) == N, f\"Roundtrip failed: from_numerals({result}) != {N}\"\n\n    # Property 3: Valid characters\n    assert all(c in ROMAN_SYMBOLS for c in result), f\"Invalid characters in {result} for N={N}\"\n\n    # Property 14: Length constraint\n    assert 1 <= len(result) <= 15, f\"Length out of range for {result} (N={N})\"\n\n    # Property 4: No 'VV', 'LL', 'DD'\n    assert 'VV' not in result and 'LL' not in result and 'DD' not in result, f\"Forbidden repetition found in {result} (N={N})\"\n\n    # Property 5: No 'IIII', 'XXXX', 'CCCC', 'MMMM'\n    assert 'IIII' not in result and 'XXXX' not in result and 'CCCC' not in result and 'MMMM' not in result, f\"Forbidden repetition found in {result} (N={N})\"\n\n    # Property 6 & 7: Subtractive pairs only and no invalid two-symbol sequences\n    INVALID_TWO_SYMBOLS = {'IL', 'IC', 'ID', 'IM', 'VX', 'VL', 'VC', 'VD', 'VM', 'LC', 'LD', 'LM', 'DM'}\n    ALLOWED_SUBTRACTIVE_PAIRS = {'IV', 'IX', 'XL', 'XC', 'CD', 'CM'}\n    for i in range(len(result) - 1):\n        pair = result[i:i+2]\n        if pair in INVALID_TWO_SYMBOLS:\n            assert False, f\"Invalid two-symbol sequence '{pair}' found in {result} (N={N})\"\n        s1_val = ROMAN_MAP_VALUES.get(result[i], 0)\n        s2_val = ROMAN_MAP_VALUES.get(result[i+1], 0)\n        if s1_val < s2_val:\n            assert pair in ALLOWED_SUBTRACTIVE_PAIRS, f\"Invalid subtractive pair '{pair}' found in {result} (N={N})\"\n\n    # Property 15: Token values non-increasing\n    token_values = get_token_values(result)\n    for i in range(len(token_values) - 1):\n        assert token_values[i] >= token_values[i+1], f\"Token values not non-increasing in {result} (N={N})\"\n\n    # Property 12 & 13: Specific edge values (if N is 1 or 3999)\n    if N == 1:\n        assert result == 'I', f\"to_numerals(1) expected 'I', got '{result}'\"\n    if N == 3999:\n        assert result == 'MMMCMXCIX', f\"to_numerals(3999) expected 'MMMCMXCIX', got '{result}'\"\n"
        },
        {
          "index": 2,
          "function_name": "test_function_pbt_2",
          "description": "This implementation focuses primarily on error handling for invalid input types and out-of-range integer values, asserting that the correct exceptions (TypeError or ValueError) are raised. It also includes direct assertions for specific, well-known Roman numeral conversions.",
          "code": "def test_function_pbt_2(N: Any) -> None:\n    \"\"\"Property-based test function generated by LLM.\n\n    This implementation focuses primarily on error handling for invalid input types and out-of-range integer values, asserting that the correct exceptions (TypeError or ValueError) are raised. It also includes direct assertions for specific, well-known Roman numeral conversions.\n    \"\"\"\n    print(f\"Testing N={N}\")\n\n    # Property 9: TypeError for non-integer N\n    if not isinstance(N, int):\n        try:\n            to_numerals(N)\n            assert False, f\"Expected TypeError for non-integer N={N}, but no exception was raised.\"\n        except TypeError:\n            pass # Expected\n        except Exception as e:\n            assert False, f\"Expected TypeError for non-integer N={N}, but got {type(e).__name__}: {e}\"\n        return # Skip further checks for invalid types\n\n    # Properties 10 & 11: ValueError for out-of-range N\n    if not (1 <= N <= 3999):\n        try:\n            to_numerals(N)\n            assert False, f\"Expected ValueError for out-of-range N={N}, but no exception was raised.\"\n        except ValueError:\n            pass # Expected\n        except Exception as e:\n            assert False, f\"Expected ValueError for out-of-range N={N}, but got {type(e).__name__}: {e}\"\n        return # Skip further checks for out-of-range values\n\n    # If N is a valid integer within range, check specific values (Property 8)\n    result = to_numerals(N)\n    EXPECTED_VALUES = {\n        1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC',\n        100: 'C', 400: 'CD', 500: 'D', 900: 'CM', 1000: 'M'\n    }\n    if N in EXPECTED_VALUES:\n        assert result == EXPECTED_VALUES[N], f\"to_numerals({N}) expected '{EXPECTED_VALUES[N]}', got '{result}'\"\n"
        },
        {
          "index": 3,
          "function_name": "test_function_pbt_3",
          "description": "This implementation emphasizes structural correctness of the Roman numeral string, performing extensive substring checks to ensure adherence to repetition limits (e.g., no 'VV', 'IIII') and the absence of invalid two-symbol sequences. It also verifies that any subtractive pairs are among the allowed canonical forms.",
          "code": "def test_function_pbt_3(N: Any) -> None:\n    \"\"\"Property-based test function generated by LLM.\n\n    This implementation emphasizes structural correctness of the Roman numeral string, performing extensive substring checks to ensure adherence to repetition limits (e.g., no 'VV', 'IIII') and the absence of invalid two-symbol sequences. It also verifies that any subtractive pairs are among the allowed canonical forms.\n    \"\"\"\n    print(f\"Testing N={N}\")\n    result = to_numerals(N)\n\n    # Property 2: Type check\n    assert isinstance(result, str), f\"Expected string, got {type(result)} for N={N}\"\n\n    # Property 3: Valid characters\n    assert all(c in ROMAN_SYMBOLS for c in result), f\"Invalid characters in {result} for N={N}\"\n\n    # Property 14: Length constraint\n    assert 1 <= len(result) <= 15, f\"Length out of range for {result} (N={N})\"\n\n    # Property 4: No 'VV', 'LL', 'DD'\n    assert 'VV' not in result, f\"Forbidden 'VV' found in {result} (N={N})\"\n    assert 'LL' not in result, f\"Forbidden 'LL' found in {result} (N={N})\"\n    assert 'DD' not in result, f\"Forbidden 'DD' found in {result} (N={N})\"\n\n    # Property 5: No 'IIII', 'XXXX', 'CCCC', 'MMMM'\n    assert 'IIII' not in result, f\"Forbidden 'IIII' found in {result} (N={N})\"\n    assert 'XXXX' not in result, f\"Forbidden 'XXXX' found in {result} (N={N})\"\n    assert 'CCCC' not in result, f\"Forbidden 'CCCC' found in {result} (N={N})\"\n    assert 'MMMM' not in result, f\"Forbidden 'MMMM' found in {result} (N={N})\"\n\n    # Property 7: No invalid two-symbol sequences\n    INVALID_TWO_SYMBOLS = {'IL', 'IC', 'ID', 'IM', 'VX', 'VL', 'VC', 'VD', 'VM', 'LC', 'LD', 'LM', 'DM'}\n    for invalid_pair in INVALID_TWO_SYMBOLS:\n        assert invalid_pair not in result, f\"Invalid sequence '{invalid_pair}' found in {result} (N={N})\"\n\n    # Property 6: Subtractive principle check (s1 < s2 implies allowed pair)\n    ALLOWED_SUBTRACTIVE_PAIRS = {'IV', 'IX', 'XL', 'XC', 'CD', 'CM'}\n    for i in range(len(result) - 1):\n        s1 = result[i]\n        s2 = result[i+1]\n        val1 = ROMAN_MAP_VALUES.get(s1, 0)\n        val2 = ROMAN_MAP_VALUES.get(s2, 0)\n        if val1 < val2:\n            pair = s1 + s2\n            assert pair in ALLOWED_SUBTRACTIVE_PAIRS, f\"Invalid subtractive pair '{pair}' found in {result} (N={N})\"\n"
        },
        {
          "index": 4,
          "function_name": "test_function_pbt_4",
          "description": "This implementation prioritizes the core functional correctness by asserting the roundtrip property (from_numerals(to_numerals(N)) == N). It also strongly verifies the algorithmic behavior by checking that the parsed token values are strictly non-increasing, reflecting the greedy decomposition requirement.",
          "code": "def test_function_pbt_4(N: Any) -> None:\n    \"\"\"Property-based test function generated by LLM.\n\n    This implementation prioritizes the core functional correctness by asserting the roundtrip property (from_numerals(to_numerals(N)) == N). It also strongly verifies the algorithmic behavior by checking that the parsed token values are strictly non-increasing, reflecting the greedy decomposition requirement.\n    \"\"\"\n    print(f\"Testing N={N}\")\n    result = to_numerals(N)\n\n    # Property 2: Type check\n    assert isinstance(result, str), f\"Expected string, got {type(result)} for N={N}\"\n\n    # Property 3: Valid characters (basic check)\n    assert all(c in ROMAN_SYMBOLS for c in result), f\"Invalid characters in {result} for N={N}\"\n\n    # Property 1: Roundtrip is the primary check\n    assert from_numerals(result) == N, f\"Roundtrip failed: from_numerals({result}) != {N}\"\n\n    # Property 15: Token values non-increasing (checks greedy decomposition)\n    token_values = get_token_values(result)\n    assert len(token_values) > 0, f\"No tokens parsed for {result} (N={N})\"\n    for i in range(len(token_values) - 1):\n        assert token_values[i] >= token_values[i+1], f\"Token values not non-increasing in {result} (N={N})\"\n\n    # Also check that the sum of token values equals N, which is implicitly covered by roundtrip,\n    # but can be an additional check for the token parsing logic itself.\n    assert sum(token_values) == N, f\"Sum of parsed token values ({sum(token_values)}) does not equal N ({N}) for {result}\"\n"
        }
      ]
    }
  }
}