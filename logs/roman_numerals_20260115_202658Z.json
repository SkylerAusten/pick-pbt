{
  "timestamp_utc": "20260115_202658Z",
  "problem": "roman_numerals",
  "settings": {
    "FREEFORM_SPEC": false,
    "MODEL_NAME": "gemini-2.5-flash",
    "TEMPERATURE": 0.2,
    "MAX_OUTPUT_TOKENS": null,
    "TIMEOUT_SEC": 60,
    "python_version": "3.11.2 (main, Apr 28 2025, 14:11:48) [GCC 12.2.0]",
    "platform": "Linux-6.1.0-42-amd64-x86_64-with-glibc2.36"
  },
  "prompts": {
    "properties_prompt": "You are helping me generate property-based tests (PBT) in Python.\nMy test framework will be Hypothesis.\n\nProblem specification:\n<background>\nThis problem concerns conversion between (1) positive integers and (2) their canonical Roman numeral string representations.\n\nRoman numerals use seven symbols with fixed values:\n\t- I=1, V=5, X=10, L=50, C=100, D=500, M=1000.\n\nNumeral formation rules (canonical form):\n\t1) Additive principle: if a symbol appears after a symbol of equal or greater value, its value is added.\n\t\t Example: VI = 5 + 1 = 6.\n\t2) Subtractive principle: if a symbol appears before a symbol of greater value, its value is subtracted.\n\t\t Subtraction is restricted to these pairs only:\n\t\t\t - I before V or X (IV=4, IX=9)\n\t\t\t - X before L or C (XL=40, XC=90)\n\t\t\t - C before D or M (CD=400, CM=900)\n\t3) Repetition limits:\n\t\t\t - V, L, D must not repeat.\n\t\t\t - I, X, C, M may repeat at most 3 times consecutively.\n\t4) Order of magnitude: symbols are arranged from highest to lowest value left-to-right, except for the allowed subtractive pairs.\n\nNumeric domain:\n\t- Standard Roman numerals are defined for integers N where 1 <= N <= 3999.\n\t- The output of integer-to-Roman conversion must be a canonical string consistent with the rules above.\n</background>\n\n<custom_data_types>\nN/A\n</custom_data_types>\n\n<function_signature>\n\t- Signature: to_numerals(N: int) -> str\n\t- Meaning: Convert integer N into its canonical RomanNumeralString.\n</function_signature>\n\n<function_details>\nFunction: to_numerals\n\tInputs:\n\t\t- N: integer.\n\tPreconditions:\n\t\t- N must satisfy 1 <= N <= 3999.\n\tOutput:\n\t\t- Returns a canonical RomanNumeralString representing N.\n\tPostconditions:\n\t\t- The returned string obeys all canonical formation rules.\n\t\t- from_numerals(to_numerals(N)) == N.\n\tAlgorithmic behavior (required at the level of the mapping, not implementation details):\n\t\t- The conversion must be consistent with a greedy decomposition over the following value-to-token list in descending order:\n\t\t\t\t1000->M, 900->CM, 500->D, 400->CD, 100->C, 90->XC, 50->L, 40->XL, 10->X, 9->IX, 5->V, 4->IV, 1->I.\n\t\t- At each step, append the token while its value fits into the remaining amount, subtracting accordingly, until remainder is 0.\n\tError handling:\n\t\t- If N is outside the domain [1, 3999], the function must raise an exception (e.g., ValueError) indicating out-of-range.\n\t\t- If N is not an integer type, the function must raise an exception (e.g., TypeError) indicating invalid input type.\n</function_details>\n\nLabeled spec expectations (freeform_spec=false):\n- <background>: high-level context, definitions, and rules.\n- <custom_data_types>: any custom types, encodings, invariants, examples.\n- <function_signature>: names, parameters, return types (as text), and meaning.\n- <function_details>: precise behavior, preconditions, postconditions, errors.\n\nTask:\n- Produce 15 distinct properties of the target function(s).\n- Each property MUST be testable via random data generation (Hypothesis).\n- Phrase each property precisely using quantifiers like 'for all' / 'there exists' and include any necessary preconditions.\n- Include edge cases, invariants, metamorphic properties, and error/exception behavior when relevant.\n- Do NOT include any code.\n\nOutput requirements (STRICT):\n- Output MUST be valid JSON and NOTHING ELSE.\n- Output MUST be exactly ONE JSON object matching one of the schemas below.\n\nSchema A (success):\n{\n  \"result\": [\n    <property description string>,\n    <property description string>,\n    ...\n  ],\n  \"explanation\": null\n}\n\nSchema B (insufficient/unknown):\n{\n  \"result\": null,\n  \"explanation\": <string describing what is missing / ambiguous and what to add>\n}\n\nAdditional constraints:\n- Each property in result is a string describing one property statement.\n- Do not wrap in Markdown. Do not include code blocks.",
    "signature_strategy_prompt": "You are helping me generate property-based tests (PBT) in Python.\nMy test framework will be Hypothesis.\n\nProblem name: roman_numerals\n\nProblem specification:\n<background>\nThis problem concerns conversion between (1) positive integers and (2) their canonical Roman numeral string representations.\n\nRoman numerals use seven symbols with fixed values:\n\t- I=1, V=5, X=10, L=50, C=100, D=500, M=1000.\n\nNumeral formation rules (canonical form):\n\t1) Additive principle: if a symbol appears after a symbol of equal or greater value, its value is added.\n\t\t Example: VI = 5 + 1 = 6.\n\t2) Subtractive principle: if a symbol appears before a symbol of greater value, its value is subtracted.\n\t\t Subtraction is restricted to these pairs only:\n\t\t\t - I before V or X (IV=4, IX=9)\n\t\t\t - X before L or C (XL=40, XC=90)\n\t\t\t - C before D or M (CD=400, CM=900)\n\t3) Repetition limits:\n\t\t\t - V, L, D must not repeat.\n\t\t\t - I, X, C, M may repeat at most 3 times consecutively.\n\t4) Order of magnitude: symbols are arranged from highest to lowest value left-to-right, except for the allowed subtractive pairs.\n\nNumeric domain:\n\t- Standard Roman numerals are defined for integers N where 1 <= N <= 3999.\n\t- The output of integer-to-Roman conversion must be a canonical string consistent with the rules above.\n</background>\n\n<custom_data_types>\nN/A\n</custom_data_types>\n\n<function_signature>\n\t- Signature: to_numerals(N: int) -> str\n\t- Meaning: Convert integer N into its canonical RomanNumeralString.\n</function_signature>\n\n<function_details>\nFunction: to_numerals\n\tInputs:\n\t\t- N: integer.\n\tPreconditions:\n\t\t- N must satisfy 1 <= N <= 3999.\n\tOutput:\n\t\t- Returns a canonical RomanNumeralString representing N.\n\tPostconditions:\n\t\t- The returned string obeys all canonical formation rules.\n\t\t- from_numerals(to_numerals(N)) == N.\n\tAlgorithmic behavior (required at the level of the mapping, not implementation details):\n\t\t- The conversion must be consistent with a greedy decomposition over the following value-to-token list in descending order:\n\t\t\t\t1000->M, 900->CM, 500->D, 400->CD, 100->C, 90->XC, 50->L, 40->XL, 10->X, 9->IX, 5->V, 4->IV, 1->I.\n\t\t- At each step, append the token while its value fits into the remaining amount, subtracting accordingly, until remainder is 0.\n\tError handling:\n\t\t- If N is outside the domain [1, 3999], the function must raise an exception (e.g., ValueError) indicating out-of-range.\n\t\t- If N is not an integer type, the function must raise an exception (e.g., TypeError) indicating invalid input type.\n</function_details>\n\nLabeled spec expectations (freeform_spec=false):\n- <background>: high-level context, definitions, and rules.\n- <custom_data_types>: any custom types, encodings, invariants, examples.\n- <function_signature>: names, parameters, return types (as text), and meaning.\n- <function_details>: precise behavior, preconditions, postconditions, errors.\n\nTask:\n1) Identify the target function under test, its argument list, and its return type.\n2) Propose a standard *property-checking* function signature suitable for Hypothesis.\n   - It should accept the function under test (as a Callable) and the same inputs that function expects.\n   - It must return a boolean (True/False) indicating whether the property holds.\n3) Provide Hypothesis strategies to generate valid inputs for the property-checking function.\n   - Provide strategies for the *inputs* (not for the Callable itself).\n   - Respect any constraints/invariants from the spec.\n   - If some constraints are hard, propose assume()-style preconditions (as strings) or filtering.\n\nOutput requirements (STRICT):\n- Output MUST be valid JSON and NOTHING ELSE.\n- If the spec is insufficient or the inputs are impossible/unsupported to generate with Hypothesis, return:\n  {\"result\": null, \"explanation\": <string>}.\n- Otherwise return an object of this shape:\n  {\n    \"result\": {\n      \"function_under_test\": {\"name\": <string>, \"args\": [<string>...], \"returns\": <string>},\n      \"property_function\": {\"name\": <string>, \"typing\": <string>, \"args\": [<string>...], \"returns\": \"bool\"},\n      \"strategies\": [\n        {\"arg\": <string>, \"strategy\": <string>, \"notes\": <string|null>},\n        ...\n      ],\n      \"assumptions\": [<string>...],\n      \"imports\": [<string>...]\n    }\n  }\n- Provide at most 12 strategy entries.\n- The values in \"strategy\" should be Python expressions like 'st.integers(...)' as STRINGS (not full code)."
  },
  "responses": {
    "properties": {
      "raw": "{\n  \"result\": [\n    \"For any integer N such that 1 <= N <= 3999, to_numerals(N) must return a value of type string.\",\n    \"For any integer N such that 1 <= N <= 3999, the string returned by to_numerals(N) must be non-empty.\",\n    \"For any integer N such that 1 <= N <= 3999, every character in the string returned by to_numerals(N) must be one of 'I', 'V', 'X', 'L', 'C', 'D', 'M'.\",\n    \"For any integer N such that 1 <= N <= 3999, the characters 'V', 'L', and 'D' must each appear at most once in the string returned by to_numerals(N).\",\n    \"For any integer N such that 1 <= N <= 3999, no character 'I', 'X', 'C', or 'M' must appear more than three times consecutively in the string returned by to_numerals(N).\",\n    \"For any integer N such that 1 <= N <= 3999, the string returned by to_numerals(N) must not contain any invalid subtractive pairs (e.g., 'IL', 'IC', 'VX', 'VL', 'XD', 'XM', 'LC', 'LD', 'DM').\",\n    \"For any integer N such that 1 <= N <= 3999, the round-trip conversion from_numerals(to_numerals(N)) must be equal to N.\",\n    \"For any integer N such that N < 1, calling to_numerals(N) must raise a ValueError.\",\n    \"For any integer N such that N > 3999, calling to_numerals(N) must raise a ValueError.\",\n    \"For any input N that is not an integer type (e.g., float, string, boolean, None), calling to_numerals(N) must raise a TypeError.\",\n    \"For any integer N such that 1 <= N <= 3999, the string returned by to_numerals(N) must be identical to the string produced by a reference implementation of the specified greedy decomposition algorithm.\",\n    \"For N values of 4, 9, 40, 90, 400, and 900, to_numerals(N) must return \\\"IV\\\", \\\"IX\\\", \\\"XL\\\", \\\"XC\\\", \\\"CD\\\", and \\\"CM\\\" respectively.\",\n    \"For N values of 3, 8, 30, 80, 300, 800, and 3000, to_numerals(N) must return \\\"III\\\", \\\"VIII\\\", \\\"XXX\\\", \\\"LXXX\\\", \\\"CCC\\\", \\\"DCCC\\\", and \\\"MMM\\\" respectively.\",\n    \"For any integer N such that 1 <= N <= 3999, if the string returned by to_numerals(N) is parsed according to standard Roman numeral rules, the resulting integer value must be N.\",\n    \"For any two distinct integers N1 and N2 such that 1 <= N1 < N2 <= 3999, it must be that to_numerals(N1) is not equal to to_numerals(N2).\"\n  ],\n  \"explanation\": null\n}",
      "parsed": {
        "result": [
          "For any integer N such that 1 <= N <= 3999, to_numerals(N) must return a value of type string.",
          "For any integer N such that 1 <= N <= 3999, the string returned by to_numerals(N) must be non-empty.",
          "For any integer N such that 1 <= N <= 3999, every character in the string returned by to_numerals(N) must be one of 'I', 'V', 'X', 'L', 'C', 'D', 'M'.",
          "For any integer N such that 1 <= N <= 3999, the characters 'V', 'L', and 'D' must each appear at most once in the string returned by to_numerals(N).",
          "For any integer N such that 1 <= N <= 3999, no character 'I', 'X', 'C', or 'M' must appear more than three times consecutively in the string returned by to_numerals(N).",
          "For any integer N such that 1 <= N <= 3999, the string returned by to_numerals(N) must not contain any invalid subtractive pairs (e.g., 'IL', 'IC', 'VX', 'VL', 'XD', 'XM', 'LC', 'LD', 'DM').",
          "For any integer N such that 1 <= N <= 3999, the round-trip conversion from_numerals(to_numerals(N)) must be equal to N.",
          "For any integer N such that N < 1, calling to_numerals(N) must raise a ValueError.",
          "For any integer N such that N > 3999, calling to_numerals(N) must raise a ValueError.",
          "For any input N that is not an integer type (e.g., float, string, boolean, None), calling to_numerals(N) must raise a TypeError.",
          "For any integer N such that 1 <= N <= 3999, the string returned by to_numerals(N) must be identical to the string produced by a reference implementation of the specified greedy decomposition algorithm.",
          "For N values of 4, 9, 40, 90, 400, and 900, to_numerals(N) must return \"IV\", \"IX\", \"XL\", \"XC\", \"CD\", and \"CM\" respectively.",
          "For N values of 3, 8, 30, 80, 300, 800, and 3000, to_numerals(N) must return \"III\", \"VIII\", \"XXX\", \"LXXX\", \"CCC\", \"DCCC\", and \"MMM\" respectively.",
          "For any integer N such that 1 <= N <= 3999, if the string returned by to_numerals(N) is parsed according to standard Roman numeral rules, the resulting integer value must be N.",
          "For any two distinct integers N1 and N2 such that 1 <= N1 < N2 <= 3999, it must be that to_numerals(N1) is not equal to to_numerals(N2)."
        ],
        "explanation": null
      },
      "error": null
    },
    "pbt_signature": {
      "raw": "{\n  \"parameters\": [\n    {\n      \"name\": \"N\",\n      \"type_hint\": \"Any\"\n    }\n  ],\n  \"strategies\": [\n    {\n      \"param_name\": \"N\",\n      \"strategy\": \"st.one_of(st.integers(min_value=1, max_value=3999), st.integers(min_value=-1000, max_value=0), st.integers(min_value=4000, max_value=5000), st.floats(allow_nan=false, allow_infinity=false), st.text(), st.booleans(), st.just(null))\",\n      \"notes\": \"This strategy combines several types and ranges to cover all properties: 1. Valid integers (1-3999) for core functionality and correctness (Properties 1-7, 11-15). 2. Integers less than 1 (e.g., -1000 to 0) for ValueError on lower bound (Property 8). 3. Integers greater than 3999 (e.g., 4000 to 5000) for ValueError on upper bound (Property 9). 4. Non-integer types (floats, strings, booleans, None) for TypeError (Property 10).\"\n    }\n  ]\n}",
      "parsed": {
        "parameters": [
          {
            "name": "N",
            "type_hint": "Any"
          }
        ],
        "strategies": [
          {
            "param_name": "N",
            "strategy": "st.one_of(st.integers(min_value=1, max_value=3999), st.integers(min_value=-1000, max_value=0), st.integers(min_value=4000, max_value=5000), st.floats(allow_nan=false, allow_infinity=false), st.text(), st.booleans(), st.just(null))",
            "notes": "This strategy combines several types and ranges to cover all properties: 1. Valid integers (1-3999) for core functionality and correctness (Properties 1-7, 11-15). 2. Integers less than 1 (e.g., -1000 to 0) for ValueError on lower bound (Property 8). 3. Integers greater than 3999 (e.g., 4000 to 5000) for ValueError on upper bound (Property 9). 4. Non-integer types (floats, strings, booleans, None) for TypeError (Property 10)."
          }
        ]
      },
      "error": null
    },
    "function_body": {
      "raw": "{\"body\": \"    # Helper functions for reference implementation and from_numerals\\n    _ROMAN_MAP = [\\n        (1000, \\\"M\\\"), (900, \\\"CM\\\"), (500, \\\"D\\\"), (400, \\\"CD\\\"),\\n        (100, \\\"C\\\"), (90, \\\"XC\\\"), (50, \\\"L\\\"), (40, \\\"XL\\\"),\\n        (10, \\\"X\\\"), (9, \\\"IX\\\"), (5, \\\"V\\\"), (4, \\\"IV\\\"), (1, \\\"I\\\")\\n    ]\\n\\n    _ROMAN_VALUES = {\\n        'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000\\n    }\\n\\n    def _reference_to_numerals_impl(num: int) -> str:\\n        res = []\\n        temp_num = num\\n        for value, symbol in _ROMAN_MAP:\\n            while temp_num >= value:\\n                res.append(symbol)\\n                temp_num -= value\\n        return \\\"\\\".join(res)\\n\\n    def _from_numerals_impl(s: str) -> int:\\n        total = 0\\n        i = 0\\n        while i < len(s):\\n            if i + 1 < len(s) and _ROMAN_VALUES[s[i]] < _ROMAN_VALUES[s[i+1]]:\\n                total += _ROMAN_VALUES[s[i+1]] - _ROMAN_VALUES[s[i]]\\n                i += 2\\n            else:\\n                total += _ROMAN_VALUES[s[i]]\\n                i += 1\\n        return total\\n\\n    print(f\\\"Testing with N={N!r}\\\")\\n\\n    # --- Property 10: TypeError for non-integer N ---\\n    # If N is not an integer, to_numerals should raise TypeError.\\n    if not isinstance(N, int):\\n        with pytest.raises(TypeError, match=\\\"invalid input type|Input must be an integer\\\"):\\n            to_numerals(N)\\n        return\\n\\n    # --- Properties 8 & 9: ValueError for out-of-range N ---\\n    # If N is an integer but outside [1, 3999], to_numerals should raise ValueError.\\n    if not (1 <= N <= 3999):\\n        with pytest.raises(ValueError, match=\\\"out-of-range|Input must be between 1 and 3999\\\"):\\n            to_numerals(N)\\n        return\\n\\n    # If we reach here, N is a valid integer (1 <= N <= 3999).\\n    # Now, test properties for valid N.\\n    result = to_numerals(N)\\n\\n    # --- Property 1: to_numerals(N) returns a string ---\\n    assert isinstance(result, str), f\\\"Property 1 failed: to_numerals({N}) returned {result!r} (type {type(result)}), expected string\\\"\\n\\n    # --- Property 2: to_numerals(N) returns a non-empty string ---\\n    assert len(result) > 0, f\\\"Property 2 failed: to_numerals({N}) returned an empty string\\\"\\n\\n    # --- Property 3: Contains only valid Roman numeral characters ---\\n    VALID_ROMAN_CHARS = \\\"IVXLCDM\\\"\\n    assert all(c in VALID_ROMAN_CHARS for c in result), f\\\"Property 3 failed: to_numerals({N})='{result}' contains invalid characters\\\"\\n\\n    # --- Property 4: 'V', 'L', 'D' appear at most once ---\\n    for char in \\\"VLD\\\":\\n        assert result.count(char) <= 1, f\\\"Property 4 failed: '{char}' appears more than once in '{result}' for N={N}\\\"\\n\\n    # --- Property 5: 'I', 'X', 'C', 'M' appear at most 3 times consecutively ---\\n    for char in \\\"IXCM\\\":\\n        assert char * 4 not in result, f\\\"Property 5 failed: '{char}' appears 4 or more times consecutively in '{result}' for N={N}\\\"\\n\\n    # --- Property 6: No invalid subtractive pairs ---\\n    # These are pairs like 'IL', 'IC', 'VX', 'VL', 'XD', 'XM', 'LC', 'LD', 'DM'\\n    INVALID_SUBTRACTIVE_PAIRS = [\\\"IL\\\", \\\"IC\\\", \\\"VX\\\", \\\"VL\\\", \\\"XD\\\", \\\"XM\\\", \\\"LC\\\", \\\"LD\\\", \\\"DM\\\"]\\n    for pair in INVALID_SUBTRACTIVE_PAIRS:\\n        assert pair not in result, f\\\"Property 6 failed: Invalid subtractive pair '{pair}' found in '{result}' for N={N}\\\"\\n\\n    # --- Property 11: Matches reference implementation ---\\n    # The reference implementation is based on the specified greedy decomposition.\\n    expected_result_ref = _reference_to_numerals_impl(N)\\n    assert result == expected_result_ref, f\\\"Property 11 failed: to_numerals({N})='{result}' does not match reference '{expected_result_ref}'\\\"\\n\\n    # --- Properties 7 & 14: Round-trip conversion (from_numerals(to_numerals(N)) == N) ---\\n    # Convert the Roman numeral string back to an integer and check if it matches the original N.\\n    round_trip_N = _from_numerals_impl(result)\\n    assert round_trip_N == N, f\\\"Property 7/14 failed: from_numerals(to_numerals({N}))='{round_trip_N}', expected '{N}'\\\"\\n\\n    # Properties 12, 13, 15 are implicitly covered by the above checks, especially P11 and P7/14.\\n    # P12 and P13 are specific examples which should pass if P11 is correct.\\n    # P15 (injectivity) is covered by P7/14 (round-trip), assuming _from_numerals_impl is injective.\\n\\n    return\", \"imports\": [\"pytest\", \"typing\"], \"notes\": \"This test function covers properties 1-11 and 14 for the `to_numerals` function. It handles type and range validation by asserting that appropriate exceptions (TypeError, ValueError) are raised. For valid integer inputs (1 <= N <= 3999), it checks the return type, non-emptiness, character validity, repetition limits for 'VLD' and 'IXCM', absence of invalid subtractive pairs, and consistency with a reference greedy decomposition implementation. It also verifies the round-trip conversion `from_numerals(to_numerals(N)) == N`. Properties 12, 13, and 15 are implicitly covered by the reference implementation and round-trip checks.\"}",
      "parsed": {
        "body": "    # Helper functions for reference implementation and from_numerals\n    _ROMAN_MAP = [\n        (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"),\n        (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n        (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n    ]\n\n    _ROMAN_VALUES = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000\n    }\n\n    def _reference_to_numerals_impl(num: int) -> str:\n        res = []\n        temp_num = num\n        for value, symbol in _ROMAN_MAP:\n            while temp_num >= value:\n                res.append(symbol)\n                temp_num -= value\n        return \"\".join(res)\n\n    def _from_numerals_impl(s: str) -> int:\n        total = 0\n        i = 0\n        while i < len(s):\n            if i + 1 < len(s) and _ROMAN_VALUES[s[i]] < _ROMAN_VALUES[s[i+1]]:\n                total += _ROMAN_VALUES[s[i+1]] - _ROMAN_VALUES[s[i]]\n                i += 2\n            else:\n                total += _ROMAN_VALUES[s[i]]\n                i += 1\n        return total\n\n    print(f\"Testing with N={N!r}\")\n\n    # --- Property 10: TypeError for non-integer N ---\n    # If N is not an integer, to_numerals should raise TypeError.\n    if not isinstance(N, int):\n        with pytest.raises(TypeError, match=\"invalid input type|Input must be an integer\"):\n            to_numerals(N)\n        return\n\n    # --- Properties 8 & 9: ValueError for out-of-range N ---\n    # If N is an integer but outside [1, 3999], to_numerals should raise ValueError.\n    if not (1 <= N <= 3999):\n        with pytest.raises(ValueError, match=\"out-of-range|Input must be between 1 and 3999\"):\n            to_numerals(N)\n        return\n\n    # If we reach here, N is a valid integer (1 <= N <= 3999).\n    # Now, test properties for valid N.\n    result = to_numerals(N)\n\n    # --- Property 1: to_numerals(N) returns a string ---\n    assert isinstance(result, str), f\"Property 1 failed: to_numerals({N}) returned {result!r} (type {type(result)}), expected string\"\n\n    # --- Property 2: to_numerals(N) returns a non-empty string ---\n    assert len(result) > 0, f\"Property 2 failed: to_numerals({N}) returned an empty string\"\n\n    # --- Property 3: Contains only valid Roman numeral characters ---\n    VALID_ROMAN_CHARS = \"IVXLCDM\"\n    assert all(c in VALID_ROMAN_CHARS for c in result), f\"Property 3 failed: to_numerals({N})='{result}' contains invalid characters\"\n\n    # --- Property 4: 'V', 'L', 'D' appear at most once ---\n    for char in \"VLD\":\n        assert result.count(char) <= 1, f\"Property 4 failed: '{char}' appears more than once in '{result}' for N={N}\"\n\n    # --- Property 5: 'I', 'X', 'C', 'M' appear at most 3 times consecutively ---\n    for char in \"IXCM\":\n        assert char * 4 not in result, f\"Property 5 failed: '{char}' appears 4 or more times consecutively in '{result}' for N={N}\"\n\n    # --- Property 6: No invalid subtractive pairs ---\n    # These are pairs like 'IL', 'IC', 'VX', 'VL', 'XD', 'XM', 'LC', 'LD', 'DM'\n    INVALID_SUBTRACTIVE_PAIRS = [\"IL\", \"IC\", \"VX\", \"VL\", \"XD\", \"XM\", \"LC\", \"LD\", \"DM\"]\n    for pair in INVALID_SUBTRACTIVE_PAIRS:\n        assert pair not in result, f\"Property 6 failed: Invalid subtractive pair '{pair}' found in '{result}' for N={N}\"\n\n    # --- Property 11: Matches reference implementation ---\n    # The reference implementation is based on the specified greedy decomposition.\n    expected_result_ref = _reference_to_numerals_impl(N)\n    assert result == expected_result_ref, f\"Property 11 failed: to_numerals({N})='{result}' does not match reference '{expected_result_ref}'\"\n\n    # --- Properties 7 & 14: Round-trip conversion (from_numerals(to_numerals(N)) == N) ---\n    # Convert the Roman numeral string back to an integer and check if it matches the original N.\n    round_trip_N = _from_numerals_impl(result)\n    assert round_trip_N == N, f\"Property 7/14 failed: from_numerals(to_numerals({N}))='{round_trip_N}', expected '{N}'\"\n\n    # Properties 12, 13, 15 are implicitly covered by the above checks, especially P11 and P7/14.\n    # P12 and P13 are specific examples which should pass if P11 is correct.\n    # P15 (injectivity) is covered by P7/14 (round-trip), assuming _from_numerals_impl is injective.\n\n    return",
        "imports": [
          "pytest",
          "typing"
        ],
        "notes": "This test function covers properties 1-11 and 14 for the `to_numerals` function. It handles type and range validation by asserting that appropriate exceptions (TypeError, ValueError) are raised. For valid integer inputs (1 <= N <= 3999), it checks the return type, non-emptiness, character validity, repetition limits for 'VLD' and 'IXCM', absence of invalid subtractive pairs, and consistency with a reference greedy decomposition implementation. It also verifies the round-trip conversion `from_numerals(to_numerals(N)) == N`. Properties 12, 13, and 15 are implicitly covered by the reference implementation and round-trip checks."
      },
      "error": null,
      "generated_function": "def test_function_pbt(N: Any) -> None:\n    \"\"\"Property-based test function generated by LLM.\"\"\"\n    # Helper functions for reference implementation and from_numerals\n    _ROMAN_MAP = [\n        (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"),\n        (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n        (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n    ]\n\n    _ROMAN_VALUES = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000\n    }\n\n    def _reference_to_numerals_impl(num: int) -> str:\n        res = []\n        temp_num = num\n        for value, symbol in _ROMAN_MAP:\n            while temp_num >= value:\n                res.append(symbol)\n                temp_num -= value\n        return \"\".join(res)\n\n    def _from_numerals_impl(s: str) -> int:\n        total = 0\n        i = 0\n        while i < len(s):\n            if i + 1 < len(s) and _ROMAN_VALUES[s[i]] < _ROMAN_VALUES[s[i+1]]:\n                total += _ROMAN_VALUES[s[i+1]] - _ROMAN_VALUES[s[i]]\n                i += 2\n            else:\n                total += _ROMAN_VALUES[s[i]]\n                i += 1\n        return total\n\n    print(f\"Testing with N={N!r}\")\n\n    # --- Property 10: TypeError for non-integer N ---\n    # If N is not an integer, to_numerals should raise TypeError.\n    if not isinstance(N, int):\n        with pytest.raises(TypeError, match=\"invalid input type|Input must be an integer\"):\n            to_numerals(N)\n        return\n\n    # --- Properties 8 & 9: ValueError for out-of-range N ---\n    # If N is an integer but outside [1, 3999], to_numerals should raise ValueError.\n    if not (1 <= N <= 3999):\n        with pytest.raises(ValueError, match=\"out-of-range|Input must be between 1 and 3999\"):\n            to_numerals(N)\n        return\n\n    # If we reach here, N is a valid integer (1 <= N <= 3999).\n    # Now, test properties for valid N.\n    result = to_numerals(N)\n\n    # --- Property 1: to_numerals(N) returns a string ---\n    assert isinstance(result, str), f\"Property 1 failed: to_numerals({N}) returned {result!r} (type {type(result)}), expected string\"\n\n    # --- Property 2: to_numerals(N) returns a non-empty string ---\n    assert len(result) > 0, f\"Property 2 failed: to_numerals({N}) returned an empty string\"\n\n    # --- Property 3: Contains only valid Roman numeral characters ---\n    VALID_ROMAN_CHARS = \"IVXLCDM\"\n    assert all(c in VALID_ROMAN_CHARS for c in result), f\"Property 3 failed: to_numerals({N})='{result}' contains invalid characters\"\n\n    # --- Property 4: 'V', 'L', 'D' appear at most once ---\n    for char in \"VLD\":\n        assert result.count(char) <= 1, f\"Property 4 failed: '{char}' appears more than once in '{result}' for N={N}\"\n\n    # --- Property 5: 'I', 'X', 'C', 'M' appear at most 3 times consecutively ---\n    for char in \"IXCM\":\n        assert char * 4 not in result, f\"Property 5 failed: '{char}' appears 4 or more times consecutively in '{result}' for N={N}\"\n\n    # --- Property 6: No invalid subtractive pairs ---\n    # These are pairs like 'IL', 'IC', 'VX', 'VL', 'XD', 'XM', 'LC', 'LD', 'DM'\n    INVALID_SUBTRACTIVE_PAIRS = [\"IL\", \"IC\", \"VX\", \"VL\", \"XD\", \"XM\", \"LC\", \"LD\", \"DM\"]\n    for pair in INVALID_SUBTRACTIVE_PAIRS:\n        assert pair not in result, f\"Property 6 failed: Invalid subtractive pair '{pair}' found in '{result}' for N={N}\"\n\n    # --- Property 11: Matches reference implementation ---\n    # The reference implementation is based on the specified greedy decomposition.\n    expected_result_ref = _reference_to_numerals_impl(N)\n    assert result == expected_result_ref, f\"Property 11 failed: to_numerals({N})='{result}' does not match reference '{expected_result_ref}'\"\n\n    # --- Properties 7 & 14: Round-trip conversion (from_numerals(to_numerals(N)) == N) ---\n    # Convert the Roman numeral string back to an integer and check if it matches the original N.\n    round_trip_N = _from_numerals_impl(result)\n    assert round_trip_N == N, f\"Property 7/14 failed: from_numerals(to_numerals({N}))='{round_trip_N}', expected '{N}'\"\n\n    # Properties 12, 13, 15 are implicitly covered by the above checks, especially P11 and P7/14.\n    # P12 and P13 are specific examples which should pass if P11 is correct.\n    # P15 (injectivity) is covered by P7/14 (round-trip), assuming _from_numerals_impl is injective.\n\n    return\n"
    },
    "signature_strategies": {
      "raw": "",
      "parsed": null,
      "error": "ClientError: 429 RESOURCE_EXHAUSTED. {'error': {'code': 429, 'message': 'You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits. To monitor your current usage, head to: https://ai.dev/rate-limit. \\n* Quota exceeded for metric: generativelanguage.googleapis.com/generate_content_free_tier_requests, limit: 20, model: gemini-2.5-flash\\nPlease retry in 16.644983879s.', 'status': 'RESOURCE_EXHAUSTED', 'details': [{'@type': 'type.googleapis.com/google.rpc.Help', 'links': [{'description': 'Learn more about Gemini API quotas', 'url': 'https://ai.google.dev/gemini-api/docs/rate-limits'}]}, {'@type': 'type.googleapis.com/google.rpc.QuotaFailure', 'violations': [{'quotaMetric': 'generativelanguage.googleapis.com/generate_content_free_tier_requests', 'quotaId': 'GenerateRequestsPerDayPerProjectPerModel-FreeTier', 'quotaDimensions': {'model': 'gemini-2.5-flash', 'location': 'global'}, 'quotaValue': '20'}]}, {'@type': 'type.googleapis.com/google.rpc.RetryInfo', 'retryDelay': '16s'}]}}"
    },
    "property_details": {}
  }
}
